# **앱스토어 관리 프로그램 설계**

**과목** **|** 알고리즘

**과제명** **|** 알고리즘 설계과제1

# **목차**

**1.개요** 

**1. 설계의 목적**

1. 요구사항

2. 개발 환경

**2. 필요한 자료구조 및 기능**

1. 필요한 자료구조

2. 기능

**3. 기능별 알고리즘 명세**

1. 어플리케이션 등록

2. 어플리케이션 검색

3. 어플리케이션 업데이트

4. 어플리케이션 할인

5. 어플리케이션의 깊이 탐색

**4. 인터페이스 및 사용법**

1. 어플리케이션 등록

2. 어플리케이션 검색

3. 어플리케이션 업데이트

4. 어플리케이션 할인

5. 어플리케이션의 깊이 탐색

**5. 평가 및 개선 방향**

1. 구현한 알고리즘의 장점

2. 구현한 알고리즘의 단점

3. 향후 개선 방향

# **1.** **개요**

## 1) 설계의 목적

- Red Black Tree 자료구조를 이용하여 앱스토어에 등록된 애플리케이션들을 효율적으로 관리하는 프로그램을 설계한다.

## 2) 요구사항

- Red Black Tree를 직접 구현하여 이용한다.
- 판매하는 어플리케이션 관리를 위한 기능을 수행해야 한다.
- 필요한 기능은 어플리케이션 등록, 어플리케이션 검색, 어플리케이션 업데이트 어플리케이션 할인이 있다.
- 사용가능한 STL은 string, vector로 제한한다.
- 표준입력으로 입력 받고 표준출력으로 출력한다.

## 3) 개발 환경

- 개발 언어 : C++
- 개발 환경 : Visual Studio 2017

# **2.** **필요한 자료구조 및 기능**

## 1) 필요한 자료구조

- 노드

![node](https://user-images.githubusercontent.com/84285337/141727528-230ecdcb-9cd0-44fb-9f90-e654fe3867de.png)

각 어플리케이션의 ID, 이름, 용량, 가격의 정보와 부모, 왼쪽 자식, 오른쪽 자식에 대한 링크를 담고 있다.

- 레드블랙트리

![red-black-tree](https://user-images.githubusercontent.com/84285337/141727407-a023035c-cfbc-4039-ab64-66d1b1c02586.png)

앱스토어에 등록된 어플리케이션을 관리하는 자료구조다.



## 2) 기능

- 어플리케이션 등록

- 어플리케이션 검색

- 어플리케이션 업데이트

- 어플리케이션 할인

- 어플리케이션의 깊이 탐색

  

# **3.** **기능별 알고리즘 명세**

## 1) 어플리케이션 등록

- 등록하려는 어플리케이션의 ID, 이름, 용량, 가격을 입력 받아 Red Black Tree에 새로운 노드를 삽입한 뒤 해당 노드의 깊이를 출력한다. 이 때 등록되어 있다면 깊이를 출력하고 등록은 거절한다.
- 시간 복잡도 : O(log(N)) (N : 트리 내의 노드 수)

-&gt; ID로 어플리케이션 탐색 : O(log(N))

-&gt; 없다면 새로운 노드를 만들어 탐색에 실패한 위치에 삽입. : O(1)

-&gt; 이미 있다면 깊이를 출력 : O(log(N)) (어플리케이션의 깊이 탐색 참고)



## 2) 어플리케이션 검색

- 입력 받은 어플리케이션 ID를 탐색하여, 존재하면 어플리케이션의 정보를 출력한다. 만약 존재하지 않는다면 "NULL"을 출력한다.
- 시간 복잡도 : O(log(N)) (N : 트리 내의 노드 수)

-&gt; 찾으려는 ID가 현재 노드보다 크다면 오른쪽으로, 작다면 왼쪽으로 내려가면서 탐색을 진행하기 때문에 한 depth가 내려갈 때마다 탐색할 노드의 수가 1/2씩 줄어든다. : (O(log(N)))



## 3) 어플리케이션 업데이트

- 입력 받은 어플리케이션 ID를 탐색하여 존재하면, 입력 받은 이름, 용량, 가격으로 해당 어플리케이션을 업데이트하고 해당 노드의 깊이를 출력한다.
- 시간 복잡도 : O(log(N)) (N : 트리 내의 노드 수)

-&gt; ID로 어플리케이션 검색 : O(log(N))

-&gt; 이름, 용량, 가격 업데이트 : O(1)

-&gt; 해당 노드의 깊이 출력 : O(log(N)) (어플리케이션의 깊이 탐색 참고)



## 4) 어플리케이션 할인

- 입력 받은 두 정수 범위 사이에 있는 ID값을 가진 모든 어플리케이션의 가격을 입력 받은 크기만큼 할인한다.
- 시간 복잡도 : O(N) (N : 트리 내의 노드 수)

-&gt; 트리 내에 있는 모든 어플리케이션에 대해 ID값을 확인(순회) : O(N)

-&gt; 할인된 가격으로 가격 수정 : O(1)



## 5) 어플리케이션의 깊이 탐색

- 입력 받은 어플리케이션 ID를 탐색하여 존재한다면 해당 노드의 깊이를 리턴하고 없다면 0을 리턴한다.
- 시간 복잡도 : O(log(N))

-&gt; ID로 어플리케이션 탐색 : O(log(N))



# **4.** **인터페이스 및 사용법**

## 1) 어플리케이션 등록

- <img width="184" alt="insert" src="https://user-images.githubusercontent.com/84285337/141727454-0099b983-358c-4672-af82-95ce52f32a06.png">
- node : 외부에서 입력 받은 ID, 이름, 용량, 가격으로 만든 새로운 Node

-&gt; insert이전에 search를 먼저 진행하고 만약 노드가 있다면 깊이만 출력하고 종료, 없다면 삽입한 뒤 깊이를 출력하고 종료한다.

![insert2](https://user-images.githubusercontent.com/84285337/141728759-f6af3e67-e49a-4094-ba58-e7670c638d23.png)



## 2) 어플리케이션 검색

<img width="196" alt="search" src="https://user-images.githubusercontent.com/84285337/141727496-f75c0002-31b2-47cb-8dbc-0f51e0113bd2.png">

- input_id : Red Black Tree에 존재하는지 탐색할 ID

-&gt; ID값을 가지고 있는 노드가 있다면 해당 노드를 없다면 NULL을 리턴한다.

<img width="119" alt="search2" src="https://user-images.githubusercontent.com/84285337/141728725-df22cc06-0646-46c0-8bbe-e156c0093b3e.png">

(특정 Node가 리턴되었다면 해당 노드의 정보를 출력하고, NULL이 리턴되었다면 NULL을 출력한다.)



## 3) 어플리케이션 업데이트

<img width="361" alt="update" src="https://user-images.githubusercontent.com/84285337/141727503-12bf077b-7e17-49da-9fcd-0878066ae9eb.png">

- id : 입력 받은 ID
- name : 입력 받은 이름
- file_size : 입력 받은 용량
- price : 입력 받은 가격

-&gt; ID값으로 search를 진행한 뒤 찾은 Node의 이름, 용량, 가격을 업데이트한다.



<img width="192" alt="update2" src="https://user-images.githubusercontent.com/84285337/141728793-4babc2f8-205a-43b8-b040-2b9b5d7ad169.png">



## 4) 어플리케이션 할인

<img width="339" alt="discount" src="https://user-images.githubusercontent.com/84285337/141727513-6400762b-7757-498e-9e8e-68e74e56ac45.png">

- node : 순회를 위한 현재 노드
- x : 범위의 시작을 나타내는 정수
- y : 범위의 끝을 나타내는 정수
- p : 할인율

-&gt; x, y사이에 있는 ID값을 가진 노드의 가격을 P만큼 할인하여 수정한다.

<img width="153" alt="discount2" src="https://user-images.githubusercontent.com/84285337/141728813-74d305dd-31d9-4e82-bd0c-0dee16beea20.png">

<img width="138" alt="discount3" src="https://user-images.githubusercontent.com/84285337/141728828-0ae28c25-0875-4bec-9d31-83f38c591cd8.png">

<img width="148" alt="discount4" src="https://user-images.githubusercontent.com/84285337/141728833-6e163ca0-5bc0-48f5-aa18-616bbb5289b5.png">

(id가 1774327인 어플리케이션의 가격을 30으로 id가 1778330인 어플리케이션의 가격을 48로 삽입한 뒤 discount를 실행했을 때 p(10)%만큼 할인한 가격이 된 것을 볼 수 있다.)



## 5) 어플리케이션의 깊이 탐색

<img width="183" alt="finddepth" src="https://user-images.githubusercontent.com/84285337/141727519-7791ec84-5332-4dbc-aa4f-07b7df860fa3.png">

- id : 깊이를 알아내려는 어플리케이션의 ID

-&gt; ID에 해당하는 어플리케이션의 깊이를 리턴한다. 이 때 외부에서 ID로 search를 먼저 진행하기 때문에 Red Black Tree가 ID를 가지고 있지 않은 경우는 없다.

<img width="96" alt="finddepth2" src="https://user-images.githubusercontent.com/84285337/141728840-f9a2135a-eac0-48fa-86a0-843a951506b7.png">



# **5.** **평가 및 개선 방향**

## 1) 구현한 알고리즘의 장점

- 구현한 알고리즘은 데이터를 Red Black Tree의 자료구조에 저장하여 관리한다. Red Black Tree는 Balanced Binary Tree이기 때문에 탐색, 삽입, 삭제 기능에 대해 모두 O(log(N))시간 정도 소요된다. 따라서 다른 자료구조보다 대량의 정보를 저장하고 관리하는데 효율적이다.
- Red Black Tree의 Restructuring이 필요한 구조는 총 4가지가 있지만 Red Black Tree의 회전(부모 노드와 자식 노드의 위치를 바꾸는 것)을 이용하여 2가지로 변환하여 문제를 해결할 수 있다.

## 2) 구현한 알고리즘의 단점

- 어플리케이션 등록, 검색, 업데이트 이후 깊이를 출력해주어야 한다. 이를 위해 어플리케이션의 깊이를 탐색하는 함수를 따로 만들어주었고, 때문에 모든 기능을 수행한 뒤 최대 O(log(N))의 시간이 더 필요하다.

## 3) 향후 개선 방향

**-** 어플리케이션의 정보를 저장하는 노드클래스에 해당 노드의 깊이를 같이 저장하면 다른 기능들을 수행한 뒤 깊이를 출력하기 위해 발생하는 추가적인 시간이 O(log(N))이 아니라 O(1)되어 성능이 개선될 것이라고 생각한다.
